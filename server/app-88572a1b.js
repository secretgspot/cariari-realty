'use strict';

var api = require('./api-12e8b0c7.js');

const CONTEXT_KEY = {};

const preload = () => ({});

/* src\routes\_layout.svelte generated by Svelte v3.12.1 */

const Layout = api.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `


	${$$slots.default ? $$slots.default({}) : ``}
	`;
});

/* src\routes\_error.svelte generated by Svelte v3.12.1 */

const css = {
	code: ".error-wrapper.svelte-13mwjh8{width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;flex-direction:column}@media screen and (orientation: portrait){.logo-group.svelte-13mwjh8{flex-direction:column}}.logo-group.svelte-13mwjh8{display:flex;align-items:center;user-select:none;cursor:pointer}.logo-group.svelte-13mwjh8 h1.svelte-13mwjh8{text-transform:uppercase;font-family:'Economica', sans-serif;margin:1rem 2rem}.error-group.svelte-13mwjh8{display:flex;justify-content:center;align-items:center;flex-direction:column;padding:2rem 3rem;margin:3rem;border:1px dotted;border-radius:9px}",
	map: "{\"version\":3,\"file\":\"_error.svelte\",\"sources\":[\"_error.svelte\"],\"sourcesContent\":[\"<script>\\n\\timport { goto } from '@sapper/app';\\n\\timport LogoSvg from '../components/UI/LogoSvg.svelte';\\n\\texport let status;\\n\\texport let error;\\n\\n\\tconst dev = undefined === 'development';\\n</script>\\n\\n<style>\\n\\t.error-wrapper {\\n\\t\\twidth: 100vw;\\n\\t\\theight: 100vh;\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: center;\\n\\t\\talign-items: center;\\n\\t\\tflex-direction: column;\\n\\t}\\n\\t@media screen and (orientation: portrait) {\\n\\t\\t.logo-group { flex-direction: column; }\\n\\t}\\n\\t.logo-group {\\n\\t\\tdisplay: flex;\\n\\t\\talign-items: center;\\n\\t\\tuser-select: none;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.logo-group h1 {\\n\\t\\ttext-transform: uppercase;\\n\\t\\tfont-family: 'Economica', sans-serif;\\n\\t\\tmargin: 1rem 2rem;\\n\\t}\\n\\n\\t.error-group {\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: center;\\n\\t\\talign-items: center;\\n\\t\\tflex-direction: column;\\n\\t\\tpadding: 2rem 3rem;\\n\\t\\tmargin: 3rem;\\n\\t\\tborder: 1px dotted;\\n\\t\\tborder-radius: 9px;\\n\\t}\\n</style>\\n\\n<svelte:head>\\n\\t<title>{status}</title>\\n</svelte:head>\\n\\n<section class=\\\"error-wrapper\\\">\\n\\t<div class=\\\"logo-group\\\" on:click=\\\"{() => goto('/')}\\\">\\n\\t\\t<h1>Cariari</h1>\\n\\t\\t<!-- <Logo type=\\\"regular\\\" color=\\\"gold\\\" size=\\\"150\\\" /> -->\\n\\t\\t<LogoSvg animate=\\\"{true}\\\" style=\\\"gold\\\" size=\\\"150\\\" time=\\\"{12}\\\" />\\n\\t\\t<h1>Realty</h1>\\n\\t</div>\\n\\n\\t<div class=\\\"error-group\\\">\\n\\t\\t<h1>{status}</h1>\\n\\n\\t\\t<p>{error.message}</p>\\n\\n\\t\\t{#if dev && error.stack}\\n\\t\\t\\t<pre>{error.stack}</pre>\\n\\t\\t{/if}\\n\\t</div>\\n</section>\\n\"],\"names\":[],\"mappings\":\"AAUC,cAAc,eAAC,CAAC,AACf,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,cAAc,CAAE,MAAM,AACvB,CAAC,AACD,OAAO,MAAM,CAAC,GAAG,CAAC,cAAc,QAAQ,CAAC,AAAC,CAAC,AAC1C,WAAW,eAAC,CAAC,AAAC,cAAc,CAAE,MAAM,AAAE,CAAC,AACxC,CAAC,AACD,WAAW,eAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,OAAO,AAChB,CAAC,AACD,0BAAW,CAAC,EAAE,eAAC,CAAC,AACf,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,WAAW,CAAC,CAAC,UAAU,CACpC,MAAM,CAAE,IAAI,CAAC,IAAI,AAClB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,cAAc,CAAE,MAAM,CACtB,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,MAAM,CAAE,IAAI,CACZ,MAAM,CAAE,GAAG,CAAC,MAAM,CAClB,aAAa,CAAE,GAAG,AACnB,CAAC\"}"
};

const Error$1 = api.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	
	let { status, error } = $$props;

	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);

	$$result.css.add(css);

	return `${($$result.head += `<title>${api.escape(status)}</title>`, "")}

	<section class="error-wrapper svelte-13mwjh8">
		<div class="logo-group svelte-13mwjh8">
			<h1 class="svelte-13mwjh8">Cariari</h1>

			${api.validate_component(api.LogoSvg, 'LogoSvg').$$render($$result, {
		animate: true,
		style: "gold",
		size: "150",
		time: 12
	}, {}, {})}
			<h1 class="svelte-13mwjh8">Realty</h1>
		</div>

		<div class="error-group svelte-13mwjh8">
			<h1>${api.escape(status)}</h1>

			<p>${api.escape(error.message)}</p>

			${  `` }
		</div>
	</section>`;
});

/* src\node_modules\@sapper\internal\App.svelte generated by Svelte v3.12.1 */

const App = api.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	

	let { stores, error, status, segments, level0, level1 = null } = $$props;

	api.setContext(CONTEXT_KEY, stores);

	if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0) $$bindings.stores(stores);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);
	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.segments === void 0 && $$bindings.segments && segments !== void 0) $$bindings.segments(segments);
	if ($$props.level0 === void 0 && $$bindings.level0 && level0 !== void 0) $$bindings.level0(level0);
	if ($$props.level1 === void 0 && $$bindings.level1 && level1 !== void 0) $$bindings.level1(level1);

	return `


	${api.validate_component(Layout, 'Layout').$$render($$result, Object.assign({ segment: segments[0] }, level0.props), {}, {
		default: () => `
		${ error ? `${api.validate_component(Error$1, 'Error').$$render($$result, { error: error, status: status }, {}, {})}` : `${api.validate_component(((level1.component) || api.missing_component), 'svelte:component').$$render($$result, Object.assign(level1.props), {}, {})}` }
	`
	})}`;
});

// This file is generated by Sapper — do not edit it!

const ignore = [];

const components = [
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-99488c2b.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-f4d7dd28.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:property/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./list-a2534873.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:property/list.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-dc151fe6.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:property/[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-3ee77e3e.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:[slug].svelte__"
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// property/index.svelte
		pattern: /^\/property\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// property/list.svelte
		pattern: /^\/property\/list\/?$/,
		parts: [
			null,
			{ i: 2 }
		]
	},

	{
		// property/[slug].svelte
		pattern: /^\/property\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 3, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// [slug].svelte
		pattern: /^\/([^\/]+?)\/?$/,
		parts: [
			{ i: 4, params: match => ({ slug: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: api.writable({}),
	preloading: api.writable(null),
	session: api.writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;

let target;

let uid = 1;

let cid;

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

exports.App = App;
exports.error = Error$1;
exports.root = Layout;
